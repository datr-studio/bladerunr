#' Execute your test functions smoothly with control
#'
#' `blade_runr()` sets your tests in motion. After setting them up with
#' `blade_setup()`, this function takes a grid of parameters generated by
#' `blade_params()` and iterates over it, executing your functions for each
#' individual test case.
#'
#' @param grid A grid of test parameters, ideally generated by `blade_params()`.
#'

#'
#' @importFrom vroom vroom_write
#' @importFrom stringr str_detect str_pad
#'
#' @export
#'
#' @return The value of the post_runr function, as specified in `blade_setup()`
#' @examples
#' blade_setup(
#'   run_name = "test_run",
#'   runr = function() 1,
#' )
#' params <- list(
#'   a = seq(1:3),
#'   b = 2
#' )
#' grid <- blade_params(params)
#' blade_runr(grid)
blade_runr <- function(grid) {
  check_args("blade_runr requires a dataframe grid to run.", any(class(grid) == "data.frame"))
  if (class(grid)[[1]] != "tbl_df") {
    grid <- as_tibble(grid)
  }

  if (is.null(get_config("runr"))) {
    cli::cli_abort("`blade_setup` must be called first to setup your runrs")
  }

  # Prepare output directory if user requested one
  output_dir <- get_config("output_dir")
  run_name <- get_config("run_name")
  context <- list(test_n = -1, run_name = run_name, output_dir = output_dir)
  if (!is.null(output_dir)) {
    prepare_dir(output_dir, run_name)
    save_grid(grid, output_dir, run_name)
  }



  # Prepare Runrs

  # Context
  n_tests <- nrow(grid)
  durations <- rep(NA, n_tests)
  skipped_tests <- tibble::tibble(
    test_n = integer(),
    attempt = integer(),
    reason = character(),
    details = character()
  )
  start_time <- Sys.time()
  max_attempts <- get_config("max_attempts")
  timeout <- get_config("timeout")

  # Execute Search
  opening_logo()
  cli::cli_alert_info("Beginning tests...")
  run_start <- Sys.time()
  purrr::walk(seq_len(n_tests), function(n) {
    iteration_start <- Sys.time()

    # Setup Iteration
    announce(n, n_tests, mean(durations, na.rm = TRUE), start_time, run_start)
    cli::cli
    output_open()
    row_params <- (grid[n, ])
    attempts <- 0

    # Setup context

    context$test_n <<- n

    # Pre Runr
    pre_runr <- get_config("pre_runr")
    if (!is.null(pre_runr)) {
      pre_runr(row_params, context)
    }

    # Runr
    runr <- get_config("runr")
    while (attempts < max_attempts) {
      if (!is.null(timeout)) {
        res <- with_time_limit(timeout, runr, row_params, context, attempts, skipped_tests)
      } else {
        res <- without_time_limit(runr, row_params, context, attempts, skipped_tests)
      }
      skipped_tests <<- res$skipped_tests
      f_res <- res$f_res
      if (res$success) break
      attempts <- attempts + 1
    }
    if (attempts < max_attempts) {
      # Post Runr
      post_runr <- get_config("post_runr")
      if (!is.null(post_runr)) {
        post_runr(f_res, context)
      }
      output_close()
    } else {
      output_close()
      skip_msg(n)
    }

    # Final Iteration Block
    elapsed <- as.numeric(Sys.time() - iteration_start, unit = "secs")
    durations[n] <<- elapsed
  })

  # Final Code
  final_run_msg(skipped_tests)
}

prepare_dir <- function(output_dir, run_name) {
  if (!dir.exists(file.path(output_dir, run_name))) {
    dir.create(file.path(output_dir, run_name), recursive = TRUE)
  } else {
    overwrite_prompt(run_name)
    msg <- "Are you sure you want to proceed? [Y/n]: "

    confirm <- tolower(input(msg))
    if (confirm == "y" || confirm == "") {
      purrr::walk(list.files(file.path(output_dir, run_name), full.names = T), unlink)
    } else {
      cli::cli_alert_danger("Overwrite is necessary to continue. Please save the files or use a different run name.")
      stop_quietly()
    }
  }
}

save_grid <- function(grid, output_dir, run_name) {
  vroom::vroom_write(grid, paste0(file.path(output_dir, run_name), "/grid.tsv"))
}

with_time_limit <- function(time_limit, f, params, context, attempt, skipped_tests) {
  setTimeLimit(elapsed = time_limit, transient = TRUE)
  on.exit({
    setTimeLimit(elapsed = Inf, transient = FALSE)
  })

  tryCatch(
    {
      f_res <- f(params, context)
      return(list(success = TRUE, f_res = f_res, skipped_tests = skipped_tests))
    },
    error = function(e) {
      if (grepl("reached elapsed time limit|reached CPU time limit", e$message)) {
        # we reached timeout, apply some alternative method or do something else
        timeout_msg(context$test_n, time_limit)
        skipped_tests <- tibble::add_row(
          skipped_tests,
          test_n = context$test_n,
          attempt = attempt + 1,
          reason = "Timeout",
          details = NA_character_
        )
        return(list(success = FALSE, f_res = NULL, skipped_tests = skipped_tests))
      } else {
        # error not related to timeout
        msg <- conditionMessage(e)
        call <- rlang::expr_text(unclass(e)$call)
        error_msg(context$test_n, msg, call)
        skipped_tests <- tibble::add_row(
          skipped_tests,
          test_n = context$test_n,
          attempt = attempt + 1,
          reason = "Runr failure",
          details = paste0(msg, " error occured attempting ", call)
        )
        return(list(success = FALSE, f_res = NULL, skipped_tests = skipped_tests))
      }
    }
  )
}

without_time_limit <- function(f, params, context, attempt, skipped_tests) {
  tryCatch(
    {
      f_res <- f(params, context)
      return(list(success = TRUE, f_res = f_res, skipped_tests = skipped_tests))
    },
    error = function(e) {
      msg <- conditionMessage(e)
      call <- rlang::expr_text(unclass(e)$call)
      error_msg(context$test_n, msg, call)
      skipped_tests <- tibble::add_row(
        skipped_tests,
        test_n = context$test_n,
        attempt = attempt + 1,
        reason = "Runr failure",
        details = paste0(msg, " error occured attempting ", call)
      )
      return(list(success = FALSE, f_res = NULL, skipped_tests = skipped_tests))
    }
  )
}