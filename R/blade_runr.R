#' Execute your test functions smoothly with control
#'
#' `blade_runr()` sets your tests in motion. After setting them up with
#' `blade_setup()`, this function takes a grid of parameters generated by
#' `blade_params()` and iterates over it, executing your functions for each
#' individual test case.
#'
#' @param grid A grid of test parameters, ideally generated by `blade_params()`.
#'

#'
#' @importFrom vroom vroom_write
#' @importFrom datr printf
#' @importFrom stringr str_detect str_pad
#'
#' @export
#'
#' @return The value of the post_runr function, as specified in `blade_setup()`
#' @examples
#' blade_setup(
#'   run_name = "test_run",
#'   runr = function() 1,
#' )
#' params <- list(
#'   a = seq(1:3),
#'   b = 2
#' )
#' grid <- blade_params(params)
#' blade_runr(grid)
blade_runr <- function(grid) {
  check_args("`grid` must be a dataframe", any(class(grid) == "data.frame"))
  if (class(grid)[[1]] != "tbl_df") {
    grid <- as_tibble(grid)
  }

  if (is.null(get_config("runr"))) {
    stop("`blade_setup` must be called first to setup your runrs", call. = FALSE)
  }

  # Prepare output directory if user requested one
  output_dir <- get_config("output_dir")
  run_name <- get_config("run_name")
  if (!is.null(output_dir)) {
    prepare_dir(output_dir, run_name)
    save_grid(grid, output_dir, run_name)
  }



  # Prepare Runrs

  # Context
  n_tests <- nrow(grid)
  durations <- rep(NA, n_tests)
  skipped_tests <- 0
  start_time <- Sys.time()
  max_attempts <- get_config("max_attempts")
  timeout <- get_config("timeout")

  context <- list(test_n = -1, run_name = run_name, output_dir = output_dir)

  # Execute Search
  cat(crayon::yellow$bold("\nRunning tests...\n"))
  purrr::walk(seq_len(n_tests), function(n) {
    iteration_start <- Sys.time()

    # Setup Iteration
    announce(n, n_tests, mean(durations, na.rm = TRUE), start_time)
    printf("$$blurred \n\n// Run Output //\n")
    row_params <- (grid[n, ])
    attempts <- 0

    # Setup context

    context$test_n <<- n

    # Pre Runr
    pre_runr <- get_config("pre_runr")
    if (!is.null(pre_runr)) {
      pre_runr(row_params, context)
    }

    # Runr
    runr <- get_config("runr")
    while (attempts < max_attempts) {
      if (!is.null(timeout)) {
        res <- with_time_limit(timeout, runr, row_params, context)
      } else {
        res <- without_time_limit(runr, row_params, context)
      }
      if (!is.null(res)) break
      attempts <- attempts + 1
    }

    if (attempts < max_attempts) {
      # Post Runr
      post_runr <- get_config("post_runr")
      if (!is.null(post_runr)) {
        if (res == ".test_passed") {
          # We can ignore the default message when the runr doesn't return anything.
          post_runr(context)
        } else {
          post_runr(res, context)
        }
      }
      printf("$$blurred \n// End Run Output // ")
    } else {
      skipped_tests <- skipped_tests + 1
      printf("$$blurred \n\n// End Run Output //\n")
      skip_msg(n)
    }

    # Final Iteration Block
    elapsed <- as.numeric(Sys.time() - iteration_start, unit = "secs")
    durations[n] <<- elapsed
  })

  # Final Code
  final_run_msg(skipped_tests)
}

prepare_dir <- function(output_dir, run_name) {
  if (!dir.exists(file.path(output_dir, run_name))) {
    dir.create(file.path(output_dir, run_name), recursive = TRUE)
  } else {
    cat("\n")
    printf("The {run_name} folder already exists. Continuing will overwrite any files in it.\n")
    msg <- crayon::blue(">>>") %+% " Are you sure you want to overwrite files in " %+% crayon::blue("'" %+% run_name %+% "'") %+% "? [Y/n]: "

    confirm <- tolower(input(msg))
    if (confirm == "y" || confirm == "") {
      purrr::walk(list.files(file.path(output_dir, run_name), full.names = T), unlink)
    } else {
      stop("Overwrite is necessary to continue. Please save the files or use a different run name.", call. = FALSE)
    }
  }
}

save_grid <- function(grid, output_dir, run_name) {
  vroom::vroom_write(grid, paste0(file.path(output_dir, run_name), "/grid.tsv"))
}

with_time_limit <- function(time_limit, f, params, context) {
  setTimeLimit(elapsed = time_limit, transient = TRUE)
  on.exit({
    setTimeLimit(elapsed = Inf, transient = FALSE)
  })

  tryCatch(
    {
      # f = .runr
      res <- f(params, context)
      # Functions need to return a value to confirm that they executed correctly.
      if (is.null(res)) res <- ".test_passed"
      return(res)
    },
    error = function(e) {
      if (grepl("reached elapsed time limit|reached CPU time limit", e$message)) {
        # we reached timeout, apply some alternative method or do something else
        cat(crayon::red$bold("Test run " %+% as.character(context$test_n) %+%
          " exceeded the time limit of " %+% as.character(time_limit) %+% " seconds\n"))
        return(NULL)
      } else {
        # error not related to timeout
        cat(crayon::red$bold("Test run " %+% as.character(context$test_n) %+%
          " has failed: ") %+% e[[1]] %+% "\n")
        return(NULL)
      }
    }
  )
}

without_time_limit <- function(f, params, context) {
  tryCatch(
    {
      res <- f(params, context)
      # Functions need to return a value to confirm that they executed correctly.
      if (is.null(res)) res <- ".test_passed"
      return(res)
    },
    error = function(e) {
      cat(crayon::red$bold("Test run #" %+% as.character(context$test_n) %+%
        " has failed: ") %+% e[[1]] %+% "\n")
      return(NULL)
    }
  )
}
