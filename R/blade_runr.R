#' Execute your test functions smoothly with control
#'
#' `blade_runr()` sets your tests in motion. After setting them up with `blade_setup()`, this function takes a grid of parameters generated by `blade_params()` and iterates over it, executing your functions for each individual test case.
#'
#' @param grid A grid of test parameters, ideally generated by `blade_params()`.
#'
#' @param use_sound logical. Whether sounds should be played at the completion of tests.
#'
#' @importFrom vroom vroom_write
#' @import beepr
#' @importFrom stringr str_detect str_pad
#'
#' @export
#'
#' @return The value of the post_runr function, as specified in `blade_setup()`
#' @examples
#' blade_setup(
#'   run_name = "test_run",
#'   runr = function() 1,
#' )
#' params <- list(
#'   a = seq(1:3),
#'   b = 2
#' )
#' grid <- blade_params(params)
#' blade_runr(grid)
blade_runr <- function(grid, use_sound = TRUE) {
  options("bladerunr_sound" = use_sound)

  check_args("`grid` must be a dataframe", any(class(grid) == "data.frame"))
  if (class(grid)[[1]] != "tbl_df") {
    grid <- as_tibble(grid)
  }

  run_name <- getOption("bladerunr_run_name")
  if (is.null(run_name)) {
    stop("`blade_setup` must be called to setup your runrs!", call. = FALSE)
  }

  # Prepare output directory if user requested one
  output_dir <- getOption("bladerunr_output_dir")
  if (!is.null(output_dir)) {
    prepare_dir(output_dir, run_name)
    save_grid(grid, output_dir, run_name)
  }



  # Prepare Runrs
  pre_runr <- getOption("bladerunr_pre_runr")
  runr <- getOption("bladerunr_runr")
  post_runr <- getOption("bladerunr_post_runr")
  timeout <- getOption("bladerunr_timeout")
  max_attempts <- getOption("bladerunr_max_attempts")

  # Context
  n_tests <- nrow(grid)
  durations <- rep(NA, n_tests)
  skipped_tests <- 0
  start_time <- Sys.time()

  # Execute Search
  cat(crayon::yellow$bold("\nRunning tests...\n"))
  purrr::walk(seq_len(n_tests), function(n) {
    iteration_start <- Sys.time()

    # Setup Iteration
    announce(n, n_tests, mean(durations, na.rm = TRUE), start_time)
    cat(crayon::blurred("\n\n// Run Output //\n"))
    row_params <- (grid[n, ])
    attempts <- 0

    # Pre Runr
    if (!is.null(pre_runr)) {
      pre_runr(row_params)
    }

    # Runr
    while (attempts < max_attempts) {
      if (!is.null(timeout)) {
        res <- with_time_limit(timeout, runr, n)
      } else {
        res <- without_time_limit(runr, n)
      }
      if (!is.null(res)) break
      attempts <- attempts + 1
    }

    if (attempts < max_attempts) {
      # Post Runr
      if (!is.null(post_runr)) {
        post_runr(n, run_name, output_dir)
      }
      cat(crayon::blurred("\n// End Run Output // "))
    } else {
      skipped_tests <- skipped_tests + 1
      cat(crayon::blurred("\n// End Run Output //\n"))
      skip_msg(n)
    }

    # Final Iteration Block
    elapsed <- as.numeric(Sys.time() - iteration_start, unit = "secs")
    durations[n] <<- elapsed

    if (use_sound) beepr::beep(sound = 2)
  })

  # Final Code
  if (use_sound) beepr::beep(sound = 4)
  final_run_msg(skipped_tests)
}

prepare_dir <- function(output_dir, run_name) {
  if (!dir.exists(file.path(output_dir, run_name))) {
    dir.create(file.path(output_dir, run_name), recursive = TRUE)
  } else {
    cat(crayon::magenta("\nThe ") %+% "'" %+% run_name %+% "'" %+% crayon::magenta(" folder already exists. Continuing will overwrite any files in it."))
    msg <- crayon::blue(">>>") %+% " Are you sure you want to overwrite files in " %+% crayon::blue("'" %+% run_name %+% "'") %+% "? [Y/n]: "

    confirm <- tolower(input(msg))
    if (confirm == "y" || confirm == "") {
      purrr::walk(list.files(file.path(output_dir, run_name), full.names = T), unlink)
    } else {
      stop("Overwrite is necessary to continue. Please save the files or use a different run name.", call. = FALSE)
    }
  }
}

save_grid <- function(grid, output_dir, run_name) {
  vroom::vroom_write(grid, paste0(file.path(output_dir, run_name), "/grid.tsv"))
}

with_time_limit <- function(time_limit, f, n, ...) {
  setTimeLimit(elapsed = time_limit, transient = TRUE)
  on.exit({
    setTimeLimit(elapsed = Inf, transient = FALSE)
  })

  tryCatch(
    {
      res <- f(...)
      # Functions need to return a value to confirm that they executed correctly.
      if (is.null(res)) res <- 1
      return(res)
    },
    error = function(e) {
      if (grepl("reached elapsed time limit|reached CPU time limit", e$message)) {
        # we reached timeout, apply some alternative method or do something else
        alert()
        cat("Test run #" %+% as.character(n) %+%
          " exceeded the time limit of " %+% as.character(time_limit) %+% " seconds\n")
        return(NULL)
      } else {
        # error not related to timeout
        alert()
        cat(crayon::red$bold("Test run #" %+% as.character(n) %+%
          " has failed: ") %+% e[[1]] %+% "\n")
        return(NULL)
      }
    }
  )
}

without_time_limit <- function(f, n, ...) {
  tryCatch(
    {
      res <- f(...)
      # Functions need to return a value to confirm that they executed correctly.
      if (is.null(res)) res <- 1
      return(res)
    },
    error = function(e) {
      alert()
      cat(crayon::red$bold("Test run #" %+% as.character(n) %+%
        " has failed: ") %+% e[[1]] %+% "\n")
      return(NULL)
    }
  )
}
